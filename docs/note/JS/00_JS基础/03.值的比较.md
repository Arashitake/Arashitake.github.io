---
title: 值的比较
date: 2020-07-26
lastUpdated: false
---

## 值的比较

| 含义                | 式子                                                      |
| ------------------- | --------------------------------------------------------- |
| 大于 / 小于         | `a > b`，`a < b`                                          |
| 大于等于 / 小于等于 | `a >= b`，`a <= b`                                        |
| 检查两个值的相等    | `a == b`（双等号表示相等性检查），单等号 `a = b` 表示赋值 |
| 检查两个值不相等    | `a != b`                                                  |

:::info 结果为布尔类型
所有比较运算符均返回布尔值 true 或 false
:::

### 字符串比较

1. 在比较字符串的大小时，JavaScript 会使用“字典（dictionary）”或“词典（lexicographical）”顺序进行判定
2. 换言之，字符串是按字符（母）逐个进行比较的
3. 字符串的比较算法非常简单：
   1. 首先比较两个字符串的首位字符大小
   2. 如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束
   3. 否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较
   4. 重复上述步骤进行比较，直到比较完成某字符串的所有字符为止
   5. 如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大

:::info 非真正的字典顺序，而是 Unicode 编码顺序
在上面的算法中，比较大小的逻辑与字典或电话簿中的排序很像，但也不完全相同。

比如说，字符串比较对字母大小写是敏感的。大写的 `A` 并不等于小写的 `a`。哪一个更大呢？实际上小写的 `a` 更大。这是因为在 JavaScript 使用的内部编码表中（Unicode），小写字母的字符索引值更大。
:::

### 不同类型间的比较

1. 当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小
2. 对于布尔类型值，true 会被转化为 1、false 转化为 0

:::warning 不同转换

JavaScript 会把待比较的值转化为数字后再做比较（因此 "0" 变成了 0）。若只是将一个变量转化为 Boolean 值，则会使用其他的类型转换规则。

```js
let a = 0;
alert(Boolean(a)); // false
let b = "0";
alert(Boolean(b)); // true
alert(a == b); // true!
```

:::

### 严格相等 ===

普通的相等性检查 `==` 存在一个问题，它不能区分出 0 和 false、字符串和 false

```js
alert(0 == false); // true
alert("" == false); // true
```

这是因为在比较不同类型的值时，处于相等判断符号 == 两侧的值会先被转化为数字。空字符串和 false 也是如此，转化后它们都为数字 0。

==严格相等运算符 === 在进行比较时不会做任何的类型转换==

如果 a 和 b 属于不同的数据类型，那么 a === b 不会做任何的类型转换而立刻返回 false。

```js
alert(0 === false); // false，因为被比较值的数据类型不同
```

### 对 null 和 undefined 进行比较

1. 当使用严格相等 === 比较二者时
   ```js
   // 它们不相等，因为它们属于不同的类型。
   alert(null === undefined); // false
   ```
2. 当使用非严格相等 == 比较二者时
   ```js
   // JavaScript 存在一个特殊的规则，会判定它们相等
   // 它们俩就像“一对恋人”，仅等于对方而不等于其他任何的值（只在非严格相等下成立）
   alert(null == undefined); // true
   ```
3. 当使用数学式或其他比较方法 `<` `>` `<=` `>=` 时：
   1. null/undefined 会被转化为数字：null 被转化为 0，undefined 被转化为 NaN

### 奇怪的结果：null vs 0

通过比较 null 和 0 可得：

```js
alert(null > 0); // (1) false
alert(null == 0); // (2) false
alert(null >= 0); // (3) true
```

1. 为什么会出现这种反常结果，这是因为相等性检查 `==` 和普通比较符 `>` `<` `>=` `<=` 的代码逻辑是相互独立的
2. 进行值的比较时，null 会被转化为数字，因此它被转化为了 0。这就是为什么（3）中 null >= 0 返回值是 true，（1）中 null > 0 返回值是 false

### 特立独行的 undefined

undefined 不应该被与其他值进行比较：

```js
alert(undefined > 0); // false (1)
alert(undefined < 0); // false (2)
alert(undefined == 0); // false (3)
```

1. (1) 和 (2) 都返回 false 是因为 undefined 在比较中被转换为了 NaN，而 NaN 是一个特殊的数值型值，它与任何值进行比较都会返回 false
2. (3) 返回 false 是因为这是一个相等性检查，而**undefined 只与 null 相等**，不会与其他值相等
